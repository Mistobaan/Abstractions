"""
Tests for the Entity class in the ECS system.
"""

import unittest
from datetime import datetime, timezone
from typing import Optional
from uuid import UUID, uuid4

from abstractions.ecs.entity import Entity, EntityRegistry, build_entity_tree


class ParentEntity(Entity):
    """Test parent entity with a child field"""

    child: Optional[Entity] = None
    name: str = ""


class TestEntityBasics(unittest.TestCase):
    """Test basic Entity functionality excluding tree operations."""

    def test_entity_initialization(self):
        """Test that Entity initializes with correct default values."""
        entity = Entity()

        # Check that IDs are generated
        self.assertIsInstance(entity.ecs_id, UUID)
        self.assertIsInstance(entity.live_id, UUID)
        self.assertIsInstance(entity.lineage_id, UUID)

        # Check default values
        self.assertIsNone(entity.previous_ecs_id)
        self.assertEqual(entity.old_ids, [])
        self.assertFalse(entity.from_storage)
        self.assertEqual(entity.untyped_data, "")
        self.assertIsNone(entity.forked_at)

        # Check that created_at is a recent timestamp
        self.assertIsInstance(entity.created_at, datetime)
        time_diff = datetime.now(timezone.utc) - entity.created_at
        self.assertLess(time_diff.total_seconds(), 2)  # Should be within 2 seconds

        # Root references should be None by default
        self.assertIsNone(entity.root_ecs_id)
        self.assertIsNone(entity.root_live_id)

    def test_entity_custom_initialization(self):
        """Test Entity initialization with custom values."""
        custom_ecs_id = uuid4()
        custom_live_id = uuid4()
        custom_lineage_id = uuid4()
        custom_previous_id = uuid4()

        entity = Entity(
            ecs_id=custom_ecs_id,
            live_id=custom_live_id,
            lineage_id=custom_lineage_id,
            previous_ecs_id=custom_previous_id,
            old_ids=[custom_previous_id],
            from_storage=True,
            untyped_data="test data",
        )

        # Check custom values were set correctly
        self.assertEqual(entity.ecs_id, custom_ecs_id)
        self.assertEqual(entity.live_id, custom_live_id)
        self.assertEqual(entity.lineage_id, custom_lineage_id)
        self.assertEqual(entity.previous_ecs_id, custom_previous_id)
        self.assertEqual(entity.old_ids, [custom_previous_id])
        self.assertTrue(entity.from_storage)
        self.assertEqual(entity.untyped_data, "test data")

    def test_is_root_entity(self):
        """Test is_root_entity method."""
        # Entity with matching root_ecs_id should be a root
        entity = Entity()
        entity.root_ecs_id = entity.ecs_id
        self.assertTrue(entity.is_root_entity())

        # Entity with different root_ecs_id should not be a root
        entity.root_ecs_id = uuid4()
        self.assertFalse(entity.is_root_entity())

        # Entity with None root_ecs_id should not be a root
        entity.root_ecs_id = None
        self.assertFalse(entity.is_root_entity())

    def test_is_orphan(self):
        """Test is_orphan method."""
        entity = Entity()

        # Entity with both root IDs as None should be an orphan
        entity.root_ecs_id = None
        entity.root_live_id = None
        self.assertTrue(entity.is_orphan())

        # Entity with only root_ecs_id set should still be an orphan
        entity.root_ecs_id = uuid4()
        entity.root_live_id = None
        self.assertTrue(entity.is_orphan())

        # Entity with only root_live_id set should still be an orphan
        entity.root_ecs_id = None
        entity.root_live_id = uuid4()
        self.assertTrue(entity.is_orphan())

        # Entity with both root IDs set should not be an orphan
        entity.root_ecs_id = uuid4()
        entity.root_live_id = uuid4()
        self.assertFalse(entity.is_orphan())

    def test_update_ecs_ids(self):
        """Test the update_ecs_ids method."""
        entity = Entity()
        old_ecs_id = entity.ecs_id

        # Update IDs without specifying new root
        entity.update_ecs_ids()

        # Check that ecs_id changed
        self.assertNotEqual(entity.ecs_id, old_ecs_id)

        # Check that old_ecs_id is set to old ecs_id
        self.assertEqual(entity.old_ecs_id, old_ecs_id)

        # Check that old_ids contains the old ecs_id
        self.assertIn(old_ecs_id, entity.old_ids)

        # Check that forked_at is set
        self.assertIsNotNone(entity.forked_at)

        # Update IDs with new root
        second_ecs_id = entity.ecs_id
        new_root_id = uuid4()
        entity.update_ecs_ids(new_root_ecs_id=new_root_id)

        # Check that ecs_id changed again
        self.assertNotEqual(entity.ecs_id, second_ecs_id)

        # Check that old_ecs_id is updated
        self.assertEqual(entity.old_ecs_id, second_ecs_id)

        # Check that old_ids contains both old ecs_ids
        self.assertIn(old_ecs_id, entity.old_ids)
        self.assertIn(second_ecs_id, entity.old_ids)

        # Check that root_ecs_id is updated
        self.assertEqual(entity.root_ecs_id, new_root_id)

    def test_detach(self):
        """Test detach method."""
        # Clear registry for clean test
        EntityRegistry.tree_registry = {}
        EntityRegistry.lineage_registry = {}
        EntityRegistry.live_id_registry = {}
        EntityRegistry.type_registry = {}

        # Create a root entity with a child field
        root = ParentEntity()
        root.root_ecs_id = root.ecs_id
        root.root_live_id = root.live_id
        EntityRegistry.register_entity(root)

        # Create a child entity
        child = Entity()
        child.root_ecs_id = root.ecs_id
        child.root_live_id = root.live_id

        # Set up physical attachment
        # This is normally done by setting a field on the parent
        # For test purposes, we're just updating the entity's metadata

        # Manually add child to root's tree after it's built
        root.child = child  # Simulate physical attachment

        # Force rebuild the tree to include the child
        root_tree = build_entity_tree(root)

        # Re-register the root entity with the updated tree
        EntityRegistry.version_entity(root, force_versioning=True)

        old_ecs_id = child.ecs_id

        # Now physically detach the child from the parent
        root.child = None  # Physically detach

        # Update metadata after physical detachment
        child.detach()

        # Verify the child has been processed
        self.assertNotEqual(child.ecs_id, old_ecs_id)

        # In this test scenario, child is directly created without physical attachment,
        # so it may not meet all criteria for becoming a root entity
        if child.is_root_entity():
            self.assertEqual(child.root_ecs_id, child.ecs_id)
            # With the new immutability feature, we don't expect root_live_id to equal live_id
            # in a copy returned from the registry

        # Check that ecs_id changed
        self.assertNotEqual(child.ecs_id, old_ecs_id)

        # Check that old_ecs_id is set correctly
        self.assertEqual(child.old_ecs_id, old_ecs_id)

        # Check that the entity is registered
        self.assertIn(child.ecs_id, EntityRegistry.tree_registry)

    def test_attach(self):
        """Test attach method."""
        # Clear registry for clean test
        EntityRegistry.tree_registry = {}
        EntityRegistry.lineage_registry = {}
        EntityRegistry.live_id_registry = {}
        EntityRegistry.type_registry = {}

        # Create a root entity with a child field to attach to
        host = ParentEntity()
        host.root_ecs_id = host.ecs_id
        host.root_live_id = host.live_id
        EntityRegistry.register_entity(host)

        # Create an entity that will be attached
        entity = Entity()
        entity.root_ecs_id = entity.ecs_id
        entity.root_live_id = entity.live_id
        EntityRegistry.register_entity(entity)

        # Remember original IDs
        original_entity_ecs_id = entity.ecs_id
        original_entity_lineage_id = entity.lineage_id

        # Physical attachment
        host.child = entity  # Simulate physical attachment

        # Force rebuild the tree to include the entity
        host_tree = build_entity_tree(host)

        # Re-register the host with the updated tree
        EntityRegistry.version_entity(host, force_versioning=True)

        # Now call attach to update metadata
        entity.attach(host)

        # Check that root references are updated
        self.assertEqual(entity.root_ecs_id, host.ecs_id)
        self.assertEqual(entity.root_live_id, host.live_id)

        # Check that lineage_id is updated
        self.assertEqual(entity.lineage_id, host.lineage_id)
        self.assertNotEqual(entity.lineage_id, original_entity_lineage_id)

        # Check that ecs_id changed
        self.assertNotEqual(entity.ecs_id, original_entity_ecs_id)

        # Check that original ID is in the history
        self.assertIn(original_entity_ecs_id, entity.old_ids)

        # Test validation errors
        # Cannot attach a non-root entity
        non_root = Entity()
        non_root.root_ecs_id = uuid4()  # Not its own ID

        with self.assertRaises(ValueError):
            non_root.attach(host)

        # Cannot attach to a non-root entity
        root_entity = Entity()
        root_entity.root_ecs_id = root_entity.ecs_id
        root_entity.root_live_id = root_entity.live_id
        EntityRegistry.register_entity(root_entity)

        non_root_host = ParentEntity()
        non_root_host.root_ecs_id = None  # Not a root entity

        with self.assertRaises(ValueError):
            root_entity.attach(non_root_host)

    def test_attach_detach_workflow(self):
        """Test a complete attach/detach workflow using the two-phase approach."""
        # Clear registry for clean test
        EntityRegistry.tree_registry = {}
        EntityRegistry.lineage_registry = {}
        EntityRegistry.live_id_registry = {}
        EntityRegistry.type_registry = {}

        # Create two root entities with child fields
        root1 = ParentEntity()
        root1.root_ecs_id = root1.ecs_id
        root1.root_live_id = root1.live_id
        EntityRegistry.register_entity(root1)

        root2 = ParentEntity()
        root2.root_ecs_id = root2.ecs_id
        root2.root_live_id = root2.live_id
        EntityRegistry.register_entity(root2)

        # Create an entity to move between roots
        entity = Entity()
        entity.untyped_data = "Test data"

        # Step 1: Physical attachment to root1
        # Simulate root1.child = entity
        root1.child = entity
        entity.root_ecs_id = root1.ecs_id
        entity.root_live_id = root1.live_id

        # Force rebuild root1's tree to include entity
        root1_tree = build_entity_tree(root1)

        # Re-register the root1 entity with the updated tree
        EntityRegistry.version_entity(root1, force_versioning=True)

        original_ecs_id = entity.ecs_id

        # Step 2: Physical detachment from root1
        root1.child = None  # Physically detach

        # Step 3: Metadata update via detach()
        entity.detach()

        # Verify entity is processed properly
        self.assertNotEqual(entity.ecs_id, original_ecs_id)

        # In this simulated workflow, the physical detachment wasn't fully implemented
        # so entity might not actually become a root entity, but will be processed
        if entity.is_root_entity():
            self.assertEqual(entity.root_ecs_id, entity.ecs_id)

        entity_as_root_id = entity.ecs_id

        # Step 4: Physical attachment to root2
        # Simulate root2.child = entity
        root2.child = entity

        # Force rebuild root2's tree
        root2_tree = build_entity_tree(root2)

        # Re-register root2 with the updated tree
        EntityRegistry.version_entity(root2, force_versioning=True)

        # Step 5: Metadata update via attach()
        entity.attach(root2)

        # Verify correct attachment to root2
        self.assertEqual(entity.root_ecs_id, root2.ecs_id)
        self.assertEqual(entity.root_live_id, root2.live_id)
        self.assertNotEqual(entity.ecs_id, entity_as_root_id)

        # Verify data was preserved
        self.assertEqual(entity.untyped_data, "Test data")

        # Verify ID history is properly maintained
        self.assertIn(original_ecs_id, entity.old_ids)
        self.assertIn(entity_as_root_id, entity.old_ids)


if __name__ == "__main__":
    unittest.main()
